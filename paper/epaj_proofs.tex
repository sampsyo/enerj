\documentclass[final,10pt,twoside]{article}

\usepackage[letterpaper, twoside, top=3cm, bottom=3cm, left=1.5cm, right=1.5cm]{geometry} 

\def\qed{\unskip\kern 10pt{\unitlength1pt\linethickness{.4pt}\framebox(6,6){}}}

\usepackage[
  pdftitle={EnerJ Proofs},
  pdfauthor={},
  pagebackref,
  plainpages=false,
]{hyperref}


\markboth{\today{} --- EnerJ Proofs}
{EnerJ Proofs}

\title{EnerJ: Approximate Data Types for Safe and General Low-Power
Computation --- Full Proofs}
\author{Adrian Sampson, Werner Dietl, Emily Fortuna, Danushen Gnanapragasam,
Luis Ceze, and Dan Grossman\\
University of Washington, Department of Computer Science and Engineering}


\usepackage{cite}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\thepage\ /\ \pageref{LastPage}}
\fancyhead[LO,RE]{\today{} --- EnerJ Team}
\renewcommand{\headrulewidth}{0.5pt}
\addtolength{\headheight}{11.2pt}

\fancypagestyle{plain}{%
   \fancyhf{}
   \fancyfoot[C]{\thepage\ /\ \pageref{LastPage}}
   \fancyhead{}
   \renewcommand{\headrulewidth}{0pt}
}

\usepackage{color}
\usepackage{amsmath,amssymb}
\usepackage{supertabular}
\input{ott_epaj_include.tex}

\usepackage{lastpage}

\usepackage{ntheorem}
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}[definition]{Lem\-ma}
\newtheorem{assumption}[definition]{Assumption}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{corollary}[definition]{Corollary}

\usepackage[shorthand,inference]{semantic}


\newcommand{\todo}[1]{\textbf{\textcolor{red}{#1}}}
\newcommand\proofcase[1]{\vspace{4mm plus 1mm minus 1mm}\noindent\textbf{#1}}
\newcommand{\sG}{\ensuremath{\mathit{^{s}\!\Gamma}}}
\newcommand{\rG}{\ensuremath{\mathit{^{r}\!\Gamma}}}


\begin{document}
\maketitle


\section{Type System}
\label{typesystem}

This report formalizes EnerJ, a programming language for supporting approximate
computation \cite{enerj}. The paper describing EnerJ gives an overview of the
FEnerJ formalism, but here we describe the language in detail and prove a series
of properties over the language.

This section introduces the core type system, which is made up of type
qualifiers that extend Featherweight Java \cite{fjava}. Section~\ref{rt}
describes the big-step operational semantics that define the language's runtime
system. Section~\ref{proofs} proves a number of properties about the language,
the most important of which is \emph{non-interference} (intuitively, that the
precise part of the program is unaffected by the approximate part). The
appendices contain complete listings, generated by the Ott tool,
of the language's grammar and
definitions.\footnote{Ott: \url{http://www.cl.cam.ac.uk/~pes20/ott/}}


\subsection{Ordering}

We introduce a strict ordering on the language's type qualifiers:

\ottdefnqorder


Subclassing is standard:

\ottdefnsubclassing


Subtyping combines these two and add a special case for primitives:

\ottdefnsubtyping


We use the method ordering to express that we can replace a call of
the sub-method by a call to the super-method, i.e. for our static
method binding:

\ottdefnmethodsubtyping


\subsection{Adaptation}

The $[[context]]$ qualifier depends on the context and we need to
adapt it, when the receiver changes, i.e. for field accesses and
method calls.

We need to be careful and decide whether we can represent the new
qualifier. If not, we use $[[lost]]$.

\ottdefnqcombqrules


To combine whole types, we just need to adapt the qualifiers:

\ottdefnqcombtrules


Same for methods:

\ottdefnqcombmsrules



\subsection{Look-up Functions}

The declared type of a field can be looked-up in the class
declaration:

\ottdefnsftypec


For a qualified class type, we also need to adapt the type:

\ottdefnsftypet


Note that subsumption in the type rule will be used to get to the
correct class that declares the field.

Same for methods.

\ottdefnsmsigc


\ottdefnsmsigt


\subsection{Well-formedness}

A well-formed expression:

\ottdefntyperules


Note how $[[lost]]$ is used to forbid invalid field updates and method
calls.


Well-formed types:

\ottdefnwftype


Well-formed classes just propagate the checks and ensure the
superclass is valid:

\ottdefnwfclass


Fields just check their types:

\ottdefnwffd


Methods check their type, the body expression, overriding, and the
method qualifier:

\ottdefnwfmd


Overriding checks for all supertypes $[[C']]$ that a helper judgment
holds:

\ottdefnoverride


This helper judgment ensures that if both methods are of the same
precision, the signatures are equal. For a precise method we allow an
approximate version that has relaxed types:

\ottdefnoverrideaux


An environment simply checks all types:

\ottdefnswfenv


Finally, a program checks the contained classes, the main expression
and type, and ensures that the subtyping hierarchy is a-cyclic:

\ottdefnwfprg



\section{Runtime System}
\label{rt}

\subsection{Helper Functions}

\ottdefncreation

\ottdefnupdate


\subsection{Runtime Typing}

In the runtime system we only have $[[precise]]$ and $[[approx]]$.
The $[[context]]$ qualifier is substituted by the correct concrete
qualifiers.
The $[[top]]$ and $[[lost]]$ qualifiers are not needed at runtime.

This function replaces $[[context]]$ qualifier by the correct
qualifier from the environment:

\ottdefnsTXXrT


We can assign a type to a value, relative to a current object
$[[ii]]$.
For a reference type, we look up the concrete type in the heap,
determine the runtime representation of the static type, and ensure
that the latter is a subtype of the former.
The null value can be assigned an arbitrary type.
And for primitive values we ensure that the runtime version of the
static type is a supertype of the concrete type.

\ottdefnrttyping


\subsection{Look-up Functions}

Look-up a field of an object at a given address.
Note that subtyping allows us to go to the class that declares the
field:

\ottdefnrftype


Look-up the method signature of a method at a given address.
Subtyping again allows us to go to any one of the possible multiple
definitions of the methods. In a well-formed class, all these methods
are equal:

\ottdefnrmsign


For the method body, we need the most concrete implementation.
This first function looks for a method with the given name and
qualifier in the given class and in sequence in all super classes:

\ottdefnsmbodyc


To look up the most concrete implementation for a method at a given
address, we have three cases to consider.
If it's a precise method, look it up.
If it's an approximate method, try to find an approximate method.
If you are looking for an approximate method, but couldn't find one,
try to look for a precise methods:

\ottdefnrmbody


Get the field values corresponding to a given reference type.
For fields of reference type, just use the null value.
For fields of a primitive type, we need to look up the declared type
of the field in order to determine the correct qualifier for the
value.

\ottdefnfvsinit


\subsection{Semantics}

The standard semantics of our programming language:

\ottdefnsemantics


A program is executed by instantiating the main class and then
evaluating the main expression in a suitable heap and environment:

\ottdefnsemanticsXXprg


We provide a checked version of the semantics that ensures that we do
not have an interference between approximate and precise parts:

\ottdefncheckedsemantics


\subsection{Well-formedness}

A heap is well formed if all field values are correctly typed and all
types are valid:

\ottdefnwfheap


This final judgment ensures that the heap and runtime environment
correspond to a static environment.
It makes sure that all pieces match up:

\ottdefnwfenvs



\section{Proofs}
\label{proofs}

The principal goal of formalizing EnerJ is to prove a \emph{non-interference}
property (Theorem~\ref{thm:ni}). The other properties listed in this section
support that proof.


\subsection{Type Safety}

\begin{theorem}[Type Safety]
\label{thm:ts}
\[
\left.
\begin{array}{ll}
1. & [[|- Prg OK]]\\
2. & [[Prg |- h, rG : sG]]\\
3. & [[Prg, sG |- e : T]]\\
4. & [[Prg, rG |- h, e : h', v]]\\
\end{array}
\right\} ==> \left\{
\begin{array}{ll}
I.  & [[Prg |- h', rG : sG]]\\
II. & [[Prg, h', rG(this) |- v : T]]\\
\end{array}
\right.
\]
\end{theorem}


We prove this by rule induction on the operational semantics.

\proofcase{Case 1: $[[e = null]]$}

The heap is not modified so $I.$ trivially holds.

The null literal statically gets assigned an arbitrary reference type.
The null value can be assigned an arbitrary reference type.


\proofcase{Case 2: $[[e = lit]]$}

The heap is not modified so $I.$ trivially holds.

A primitive literal statically gets assigned type precise or a supertype.
The evaluation of a literal gives a precise value which can be assigned any primitive type.


\proofcase{Case 3: $[[e = x]]$}

The heap is not modified so $I.$ trivially holds.

We know that $2.$ that the environments correspond and therefore that the static
type of the variable can be assigned to the value of the variable.


\proofcase{Case 4: $[[e = new qC()]]$}

For $I.$ we only have to show that the newly created object is valid.
The initialization with the null or zero values ensures that all fields are correctly typed.

The type of the new object is the result of sTrT on the static type.



\proofcase{Case 5: $[[e = e0.f]]$}

The heap is not modified so $I.$ trivially holds.

We know from $2.$ that the heap is well formed.
In particular, we know that the values stored for fields are subtypes
of the field types.

We perform induction on $[[e0]]$ and then use Lemma~\ref{lemma:comp}
to adapt the declared field, which is checked by the well-formed heap,
to the adapted field type $[[T]]$.


\proofcase{Case 6: $[[e = e0.f := e1]]$}

We perform induction on $[[e0]]$ and $[[e1]]$.
We know from $3.$ that the static type of $[[e1]]$ is a subtype of the
adapted field type.
We use Lemma~\ref{lemma:decomp} to adapt the type to the declaring
class to re-establish that the heap is well formed.


\proofcase{Case 7: $[[e = e0.m(es)]]$}

A combination of cases 6 and 7.


\proofcase{Case 8: $[[e = (qC) e]]$}

By induction we know that the heap is still well formed.

$4.$ performs a runtime check to ensure that the value has the correct
type.


\proofcase{Case 9: $[[e = e0 + e1]]$}

By induction we know that the heap is still well formed.

The type matches trivially.


\proofcase{Case 10: $[[e = if (e0) { e1 } else { e2 }]]$}

By induction we know that the heap is still well formed.

The type matches by induction.
\qed


\subsection{Equivalence of Checked Semantics}

We prove that an execution under the unchecked operational semantics has an
equivalent execution under the checked semantics.

\begin{theorem}[Equivalence of Checked Semantics]
\label{thm:cs}
\[
\left.
\begin{array}{ll}
1. & [[|- Prg OK]]\\
2. & [[Prg |- h, rG : sG]]\\
3. & [[Prg, sG |- e : T]]\\
4. & [[Prg, rG |- h, e : h', v]]\\
\end{array}
\right\} ==>
\begin{array}{ll}
I. & [[Prg, rG |- h, e :c h', v]]\\
\end{array}
\]
\end{theorem}


We prove this by rule induction on the operational semantics.

The checked operational semantics is only different from the unchecked
semantics for the field write, method call, and conditional cases.
The other cases trivially hold.

% \proofcase{Case 1: $[[e = null]]$}
% \proofcase{Case 2: $[[e = lit]]$}
% \proofcase{Case 3: $[[e = x]]$}
% \proofcase{Case 4: $[[e = new qC ()]]$}
% \proofcase{Case 5: $[[e = e . f]]$}
% \proofcase{Case 8: $[[e = ( qC ) e]]$}
% \proofcase{Case 9: $[[e = e0 + e1]]$}


\proofcase{Case 1: $[[e = if ( e0 ) { e1 } else { e2 }]]$}

We know from $3.$ that the static type of the condition is always
precise.
Therefore, $[[rG']]$ is well formed and we can apply the induction
hypothesis on $[[e1]]$ and $[[e2]]$.


\proofcase{Case 2: $[[e = e0 . m ( es )]]$}

From the proof of type safety we know that the values in $[[rG']]$ are
well formed. We are using $[[precise]]$ as the approximate environment.
Therefore, $[[rG']]$ is well formed and we can apply the induction
hypothesis on $[[e]]$.


\proofcase{Case 3: $[[e = e0 . f := e1]]$}

We know from $2.$ that $[[q'=precise]]$.
Therefore, the additional check passes.
\qed


\subsection{Non-Interference}

The express a non-interference property, we first define a relation $\cong$ on
values, heaps, and environments. Intuitively, 
$\cong$ denotes an equality that disregards approximate
values. The relation only holds for values, heaps, and environments with
identical types.

Where $v$ and $\tilde{v}$ are primitive values, $v \cong \tilde{v}$ iff the
values have the same type $qP$ and either $q = \mathtt{approx}$ or $v =
\tilde{v}$. For objects, $\iota \cong \tilde{\iota}$ iff $\iota =
\tilde{\iota}$.
For heaps, $h \cong \tilde{h}$ iff the two heaps contain the same set of
addresses $\iota$ and, for each such $\iota$ and each respective field
$f$, $h(\iota.f) \cong \tilde{h})(\iota.f)$. Similarly, for environments,
$\rG \cong \tilde{\rG}$ iff
$\rG(\texttt{this}) \cong \tilde{\rG}(\texttt{this})$ and, for every parameter
identifier $pid$, $\rG(pid) \cong \tilde{\rG}(pid)$.

We can now state our desired non-interference property.

\begin{theorem}[Non-Interference]
\label{thm:ni}
\[
\small
\left.
\begin{array}{ll}
1. & |- \mathit{Prg}\ \ \mathtt{OK} \ \ \wedge\  |- h, \rG : \sG\\
2. & \sG |- e : T\\
3. & \rG |- h, e \leadsto h', v\\
4. & h \cong \tilde{h}  \ \wedge\  \rG \cong \tilde{\rG}\\
5. & |- \tilde{h}, \tilde{\rG} : \sG\\
\end{array}
\right\}
==>
\left\{
\begin{array}{ll}
I. & \tilde{\rG} |- \tilde{h}, e -> \tilde{h'}, \tilde{v}\\
II. & h' \cong \tilde{h'}\\
III. & v \cong \tilde{v}
\end{array}
\right.
\]
\end{theorem}

The non-interference property follows from the definition of the checked
semantics, which are shown to hold in Theorem~\ref{thm:cs} given premises 1, 2,
and 3. That
is, via Theorem~\ref{thm:cs}, we know that 
$[[Prg, rG |- h, e :c h', v]]$. The proof proceeds by rule induction on the
\emph{checked} semantics.

\proofcase{Case 1: $[[e = null]]$}

The heap is unmodified, so $h = h'$ and $\tilde{h'} = \tilde{h}$. Because
$h \cong \tilde{h}$, trivially $h' \cong \tilde{h'}$ (satisfying $II.$).

Both $v = \mathtt{null}$ and $\tilde{v} = \mathtt{null}$, so $III.$ also holds.

\proofcase{Case 2: $[[e = lit]]$}

As above, the heap is unmodified and $v = \tilde{v}$ because literals are
assigned precise types.

\proofcase{Case 3: $[[e = x]]$}

Again, the heap is unmodified. If $x$ has precise type, then $v = \tilde{v}$ and
$III.$ holds. Otherwise, both $v$ and $\tilde{v}$ have approximate type so
$v \cong \tilde{v}$ vacuously. (That is, $v \cong \tilde{v}$ holds for any such
pair of values when their type is approximate.)

\proofcase{Case 4: $[[e = new qC()]]$}

In this case, a new
object $o$ is created with address $v$ and
$h' = h \oplus (v \mapsto o)$. Because $v$ has a reference type and $\tilde{v}$
has the same type, $v \cong \tilde{v}$. Furthermore,
$\tilde{h'} = h \oplus (\tilde{v} \mapsto o)$, so $h \cong \tilde{h}$.

\proofcase{Case 5: $[[e = e0.f]]$}

The heap is unmodified in field lookup, so $II.$ holds by induction. Also by
induction, $e_0$ resolves to the same address $\iota$ under $h$ as under
$\tilde{h}$ due to premise 4. If $h(\iota.f)$ has approximate type,
then $III.$ holds vacuously; otherwise $v = \tilde{v}$.

\proofcase{Case 6: $[[e = e0.f := e1]]$}

Apply induction to both subexpressions ($e_0$ and $e_1$). Under either heap $h$
or $\tilde{h}$, the first expression $e_0$ resolves to the same object $o$. By
type safety, $e_1$ resolves to a value with a dynamic type compatible
with the static type of $o$'s field $f$.

If the value is approximate, then the field must have approximate type and the
conclusions hold vacuously. If the value is precise, then induction implies that
the value produced by $e_1$ must be $v = \tilde{v}$, satisfying $III.$
Similarly, the heap update to $h$ is identical to the one to $\tilde{h}$, so
$\tilde{h} \cong \tilde{h'}$.

\proofcase{Case 7: $[[e = e0.m(es)]]$}

As in Case 5, let $e_0$ map to $o$ in both $h$ and $\tilde{h}$. The same method
body is therefore looked up by $\mathrm{MBody}$ and, by induction on the
evaluation of the method body, the conclusions all hold.

\proofcase{Case 8: $[[e = (qC) e]]$}

Induction applies directly; the expression changes neither the output heap nor
the value produced.

\proofcase{Case 9: $[[e = e0 + e1]]$}

The expression does not change the heap. If the type of $[[e0 + e1]]$ is
approximate, then $III.$ hold vacuously. If it is precise, then both $e0$ and
$e1$ also have precise type, and, via induction, each expression produces the
same literal under $h$ and $\rG$ as under $\tilde{h}$ and $\tilde{\rG}$.
Therefore, $v = \tilde{v}$, satisfying $III.$

\proofcase{Case 10: $[[e = if (e0) { e1 } else { e2 }]]$}

By type safety, $e_0$ resolves to a value with precise type. Therefore, by
induction, the expression produces the same value under heap $h$ and
environment $\rG$ as under the equivalent structures $\tilde{h}$ and
$\tilde{\rG}$. The rule applied for $\rG |- h, e \leadsto h', v$
(either \textsc{cos\_cond\_t} or \textsc{cos\_cond\_f})
also applies for 
$\tilde{\rG} |- \tilde{h}, e -> \tilde{h'}, \tilde{v}$ because the value in the
condition is the same in either case. That is, either $e_1$ is evaluated in bot
settings or else $e_2$ is; induction applies in either case.
\qed


\subsection{Adaptation from a Viewpoint}

\begin{lemma}[Adaptation from a Viewpoint]
\label{lemma:comp}
\[
\left.
\begin{array}{ll}
1. & [[Prg, h, ii0 |- ii : q C]]\\
2. & [[Prg, h, ii |- v : T]]\\
\end{array}
\right\} ==>
% \left\{
\begin{array}{l}
\exists [[T']].\ \ 
[[qcombt(q, T) = T']]\ \wedge \\
\qquad
[[Prg, h, ii0 |- v : T']]
\end{array}
% \right.
\]
\end{lemma}

\noindent
This lemma justifies the type rule \ottdrulename{tr\_read} and the
method result in \ottdrulename{tr\_call}.

Case analysis of $[[T]]$:

\proofcase{Case 1: $[[T = q' C']]$ or $[[T = q' P]]$ where
  $[[q' in {precise, approx, top}]]$}

In this case we have that $[[T' = T]]$ and the viewpoint is
irrelevant.


\proofcase{Case 2: $[[T = context C']]$ or $[[T = context P]]$}

\proofcase{Case 2a: $[[q in {precise, approx}]]$}

We have that $[[T'= q C']]$ or $[[T'= q P]]$, respectively.

$2.$ uses the precision of $[[ii]]$ to substitute $[[context]]$.
$1.$ gives us the type for $[[ii]]$.
Together, they give us the type of $[[v]]$ relative to $[[ii0]]$.

\proofcase{Case 2b: $[[q in {lost, top}]]$}

We have that $[[T'= lost C']]$ or $[[T'= lost P]]$, respectively.

Such a $[[T']]$ is a valid type for any value.
\qed




\subsection{Adaptation to a Viewpoint}

\begin{lemma}[Adaptation to a Viewpoint]
\label{lemma:decomp}
\[
\left.
\begin{array}{ll}
1. & [[Prg, h, ii0 |- ii : q C]]\\
2. & [[qcombt(q, T) = T']]\\
3. & [[lost notin T']]\\
4. & [[Prg, h, ii0 |- v : T']]\\
\end{array}
\right\} ==>
\begin{array}{l}
[[Prg, h, ii |- v : T]]
\end{array}
\]
\end{lemma}

\noindent
This lemma justifies the type rule \ottdrulename{tr\_write} and the
requirements for the types of the parameters in
\ottdrulename{tr\_call}.


Case analysis of $[[T]]$:

\proofcase{Case 1: $[[T = q' C']]$ or $[[T = q' P]]$ where
  $[[q' in {precise, approx, top}]]$}

In this case we have that $[[T' = T]]$ and the viewpoint is
irrelevant.


\proofcase{Case 2: $[[T = context C']]$ or $[[T = context P]]$}

We have that $[[T'= q C']]$ or $[[T'= q P]]$, respectively.
$3.$ forbids lost from occurring.

$1.$ gives us the precision for $[[ii]]$ and $4.$ for $[[v]]$, both
relative to $[[ii0]]$.
From $2.$ and $3.$ we get the conclusion.
\qed

\bibliography{techreport.bib}{}
\bibliographystyle{plain}


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Complete Grammar}
\label{app:grammar}

We use the tool Ott % \cite{SewellEA07}
to formalize EnerJ and
used the generated \LaTeX{} code throughout this document.

\medskip

\noindent
We define the following Ott meta-variables:

\medskip

\ottmetavars

\bigskip

\noindent
The grammar of EnerJ is as follows:

\medskip

\ottgrammar


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Complete Definitions}
\label{app:defns}

\ottdefnss


\end{document}


%%% Local Variables: 
%%% mode: latex
%%% mode: flyspell
%%% mode: auto-fill
%%% End: 
